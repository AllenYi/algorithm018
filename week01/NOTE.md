学习笔记
二叉树的遍历：
1.前序(pre-order) ： 根-左-右 2.中序(in-order)：左-根-右 3.后序(post-order)：左-右-根

递归：首先找到递归的终结条件，处理当前层逻辑，下探到下一层，清理当前层。思维重点如下：
  1.不要人肉进行递归（最大误区）
  2.找到最近最简的方法将其拆解成为可以重复解决的问题（重复子问题）；
  
数组 Array

访问时间快 O（1）
插入时间复杂度 O(n）
删除时间复杂度 O(n）
链表 Linked List 单链表：只有next指针，最后一个node next指针指向空 双链表：有next和previous指针 循环链表：最后一个node的next指针指向head

从头节点增加时间复杂度 O（1）
从尾节点增加时间复杂度 O（1）
添加节点时间复杂度 O（1）
删除节点时间复杂度 O（1）
访问节点时间复杂度 O（n）

跳表 Skip List （只适用于元素有序的情况）

插入 O（log n)
删除 O（log n)
搜索 O（log n) 如何加速？ 升维
1 ——————> 4 ——————> 7 ——————> 9 | | |	| | | |	| | | | | 1 —— 3 —— 4 —— 5 —— 7 —— 8 —— 9

索引高度： logn, 每层索引遍历的节点个数：3 查询任意数据的时间复杂度是O（logn) 维护成本较高 空间复杂度 O（n）

栈 Stack

先入后出
添加 O（1）
删除 O（1）
查找 O（n)

列 Queue 先入先出

添加 O（1）
删除 O（1）
查找 O（n)

双端队列 Deque

两端都能进出
添加 O（1）
删除 O（1）

优先队列 Priority Queue

插入 O（1）
取出 O（logN） 按元素的优先级取出
  
快慢指针思想：
我们设计两个指针，分别是快指针和慢指针，快指针每次走2步，而慢指针每次走1步，这样的话在当我们两个
指针在链表中如果二次相遇则链表为环形链表。或者查找链表中间点定义两个指针，一个快指针，一个慢指针，
当快指针遍历到尾节点的时候，慢指针刚好遍历到中间的节点。当节点个数为奇数时，中间节点只有一个，
当节点个数为偶数时，慢指针指向的节点和它的后继都是中间节点这种办法时间只需要遍历一次，且未开辟新空间，因此时间复杂度为O(n),空间复杂度为O(1)。  

O后面的括号中有一个函数，指明某个算法的耗时/耗空间与数据增长量之间的关系。其中的n代表输入数据的量。 
比如时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。
再比如时间复杂度O(n^2)，就代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。比如冒泡排序，就是典型的O(n^2)的算法，对n个数排序，需要扫描n×n次。 
再比如O(logn)，当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。 
O(nlogn)同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。 
O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）